1) create an interface (abstract base class ) called MEasurable , implementing abstractmethod "area" and abstractmethod "perimiter" , i.e. class Measurabe (ABC)
2) create an interface (aka ABC) called Drawable, ie class Shape (Measurable , Drawable)
4) Create three concrete implementations of Shape: Circle (which has a radius) , Triangle (assume equal length sides), and Rectangle (which has a length and width). Note that you will need to write implementations for the abstractmethods of Measurable and Drawable - area returns the area, perimeter returns the perimeter, and draw just prints to the screen that it s drawng a shape with such and such features 
5) Ensure that the parameters of each concrete implementation remain private (i.e. self.__radius instead of self.radius) and implement a @property getter for each shape's parameter(s), ie def radius (self)->float: will have a @property decorator.
6) Create a class called ShapeGroup that inherits from Mesurable , Drawable and has as its attribute a list of Shapes. Then implement and add_shape method, as well as area (which calculates the sum of areas of all the shapes), perimeter (which calculates and returns the sum of all perimeters of all the shapes), and draw, which calls the draw method for each shape in its list
7) In ShapeGroup, implement the __iter__ and __len__ methods, so we can easily iterate through the shapes and count the number of shapes (hint: return iter (self.shapes). But make sure you write a unit test for this. I am sure you can figure out __len__ yourself)
8) Make sure each class  has a docstring and write unit tests for ShapeGroup and at least one concrete implementation of SHape